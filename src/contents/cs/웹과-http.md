---
title: 웹과 HTTP
date: 2022-04-11 20:04:73
categories: ["CS"]
summary: "웹의 애플리케이션 계층 프로토콜인 HTTP(HyperText Transfer Protocol)은 웹의 중심이다."
thumbnail: "../../static/test.png"
---

# 웹과 HTTP

# HTTP 개요

- 웹의 애플리케이션 계층 프로토콜인 HTTP(HyperText Transfer Protocol)은 웹의 중심이다.
- HTTP는 두 가지 프로그램으로 구현된다.(클라이언트, 서버 프로그램)
- 서로 다른 종단 시스템에서 수행되는 클라이언트 프로그램과 서버 프로그램은 서로 HTTP 메시지를 교환하여 통신한다.
- HTTP는 메시지의 구조 및 클라이언트와 서버가 메시지를 어떻게 교환하는 지에 대해 정의하고 있다.

웹 구성 요소들

- 웹 페이지(web page)는 객체들로 구성된다.
- 객체(object)는 단순히 단일 URL로 지정할 수 있는 하나의 파일이다.
- 대부분 웹 페이지는 기본 HTML 파일과 여러 참조 객체로 구성된다.
- 기본 HTML 파일은 페이지 내부의 다른 객체를 그 객체의 URL로 참조한다.

- HTTP는 웹 클라이언트가 웹 서버에게 웹 페이지를 어떻게 요청하는지와 서버가 클라이언트로 어떻게 웹 페이지를 전송하는지를 정의한다.
  - 사용자가 웹 페이지를 요청할 때, 브라우저는 페이지 내부의 객체에 대한 HTTP 요청 메시지를 서버에 보낸다.
  - 서버는 요청을 수신하고 객체를 포함하는 HTTP 응답 메시지로 응답한다.
- HTTP는 TCP를 전송 프로토콜로 사용한다.
- 먼저 서버에 TCP 연결을 시작하고, 일단 연결이 이뤄지면 브라우저와 서버 프로세스는 그들의 소켓 인터페이스를 통해 TCP로 접속한다.
- TCP에 의해 HTTP에게 신뢰적인 데이터 전송 서비스가 제공되고 클라이언트 프로세스가 발생시킨 모든 HTTP 요청 메시지가 궁극적으로 서버에 잘 도착한다는 것을 의미한다. (서버 프로세스의 HTTP 응답 메시지로 마찬가지다.)
- 서버가 클라이언트에게 요청 파일을 보낼 때, 서버는 클라이언트에 관한 어떤 상태 정보도 저장하지 않는다. (따라서 HTTP를 비상태 프로토콜(stateless)이라고도 한다.)

## 비지속 연결과 지속 연결

- 클라이언트-서버 상호작용이 TCP상에서 발생할 때 애플리케이션 개발자는 다음과 같은 중요한 결정을 할 필요가 있다.
  - 각 요구/응답 쌍이 **분리된 TCP 연결**을 통해 보내져야 하는가?
    (비지속 연결, non-persistent connection)
  - 모든 요구와 해당 하는 응답들이 **같은 TCP 연결상**으로 보내져야 하는가?
    (지속 연결, persistent connection)

### 비지속 연결 HTTP

HTTP 연결 수행 과정 예시

Ex) [http://www.someSchool.edu/someDepartment/home.index](http://www.someSchool.edu/someDepartment/home.index) 라는 사이트로의 연결 수행 과정

1. HTTP 클라이언트는 HTTP의 기본 포트 번호 80을 통해 [www.soemSchool.edu](http://www.soemSchool.edu) 서버로 TCP 연결을 시도 한다. (클라이언트와 서버에 소켓이 있게 된다)
2. HTTP 클라이언트는 1단계에서 설정된 TCP 연결 소켓을 통해 서버로 HTTP 요청 메시지를 보낸다. (뒤의 경로 someDepartment~를 포함한다)
3. HTTP 서버는 1단계에서 설정된 연결 소켓을 통해 요청 메시지를 받아, 저장장치로부터 뒤 경로에 해당하는 객체를 추출한다. HTTP 응답 메시지에 그 객체를 캡슐화하여 소켓을 통해 클라이언트로 보낸다.
4. HTTP서버는 TCP에게 TCP연결을 끊으라고 한다. (실제로 TCP 클라이언트가 응답 메시지를 올바로 받을 때까지 연결을 끊지 않는다.)
5. HTTP 클라이언트가 응답 메시지를 받으면, TCP 연결이 중단된다. 메시지는 캡슐화된 객체가 HTML 파일인 것을 나타낸다. 클라이언트는 응답 메시지로부터 파일을 추출하고 HTML 파일을 조사한다.
6. 그 이후 참조되는 객체에 대해 4단계를 반복한다.

- HTTP는 클라이언트가 웹 페이지를 어떻게 해석하는지 관심이 없고 클라이언트 HTTP 프로그램과 서버 HTTP 프로그램 사이의 통신 프로토콜만 정의한다.
- 작은 패킷이 클라이언트로부터 서버까지 갔다가 다시 되돌아오는 데 걸리는 시간을 **RTT(rount-trip time)**이라 한다. (RTT는 패킷 전파 지연, 패킷 큐잉 지연, 패킷 처리 지연 등을 포함)
- 사용자가 하이퍼링크를 클릭하면 브라우저와 웹 사이에서 TCP 연결을 시도하게 되는데 이는 세 방향 핸드셰이크를 포함한다.
  - 세 방향 핸드셰이크란, 클라이언트가 작은 TCP 메시지를 서버로 보내고, 서버는 작은 메시지로 응답하고, 마지막으로 클라이언트가 다시 서버에게 응답한다.
  - RTT는 처음 두 부분이 경과하는 한 RTT가 계산되며, 클라이언트는 HTTP 요청 메시지를 TCP 연결로 보내면서 핸드 셰이크의 세 번째 부분(응답)을 함께 보낸다.
- 요청 메시지가 서버에 도착하면 서번느 HTML 파일을 TCP 연결로 보내는데 이 역시 또 하나의 RTT를 필요로 한다. 따라서 대략 총응답 시간은 2 RTT와 HTML 파일을 서버가 전송하는 데 걸리는 시간을 더한 것이다.

## 지속 연결 HTTP

- 비지속 연결은 몇 가지 단점이 있다.
  1. 각 요청 객체에 대한 새로운 연결이 설정되고 유지되어야 한다. (웹 서버에 심각한 부담을 줄 수 있다.)
  2. 각 객체는 2 RTT를 필요로 한다.
- HTTP1.1 지속 연결에서 서번느 응답을 보낸 후에 TCP 연결을 그대로 유지한다. 이를 통해 전체 웹페이지를 하나의 지속 TCP 연결을 통해 보낼 수 있다.
- 일반적으로 HTTP 서버는 일정 기간 사용되지 않으면 연결을 닫는다.

## HTTP 메시지 포맷

- HTTP 메시지 포맷은 요청 메시지와 응답 메시지로 나뉜다.

### HTTP 요청 메시지

```
GET/somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr
```

- HTTP 요청 메시지는 일반 ASCII 텍스트로 쓰여 있어 사람들이 읽을 수 있다.
- 메시지가 다섯 줄로 되어 있고 각 줄은 CR과 LF로 구별된다. 특정 요청 메시지는 5줄 이상 또는 하나의 줄이 될 수도 있다.
- HTTP 요청 메시지의 첫 줄은 **요청 라인(request line)이라 부르고, 이후 줄 들은 헤더 라인(header line)이라 부른다.**
  - 요청 라인은 3개의 필드(method, URL, HTTP 버전)를 갖는다.
    - method는 GET, POST, HEAD, PUT 그리고 DELETE를 포함하는 여러 가지 다른 값을 갖는다.
    - HTTP 메시지의 대부분 GET 방식을 사용한다.
  - 헤더 라인은 객체가 존재하는 호스트를 명시한다.
    - 호스트 헤더라인이 제공하는 정보는 웹 프록시 캐시에서 필요로 한다.
    - Connection : close 헤더라인은 브라우저가 서버에 지속 연결 사용을 원하지 않는다는 것을 의미한다.
    - User-agent : 헤더 라인은 서버에 요청을 하는 브라우저 타입을 명시한다.
    - Accept-language : 헤더는 사용자가 객체의 언어 버전(없으면 기본)을 원하고 있음을 나타낸다.
- HTTP 요청 메시지의 일반 포맷에는 개체 몸체(entity body)도 존재하는데 GET 방식에서는 비어 있고, POST 방식에서 사용된다.
  - HTTP 클라이언트는 사용자가 폼을 채워 넣을때 POST 방식을 사용하지만 반드시 POST 방식을 사용해야 할 필요는 없다.
  - HTML 폼은 흔히 GET 방식을 사용하고 요청된 URL의 입력 데이터를 전송한다. (URL 쿼리스트링 방식)
- HEAD 방식은 GET 방식과 유사하며, 서버가 HEAD 방식을 가진 요청을 받으면 HTTP 메시지로 응답하며 요청 객체는 보내지 않는다. (주로 디버깅에 사용)
- PUT 방식은 웹 서버에 업로드할 객체를 필요로 하는 애플리케이션에 의해 사용한다.
- DELETE 방식은 사용자 또는 애플리케이션이 웹 서버에 있는 객체를 지우는 것을 허용한다.

### HTTP 응답 메시지

```
HTTP/1.1 200 OK
Connection : close
Date : Tue, 18 Aug 2015 15:44:04 GMT
Server : Apache/2.2.3 (CentOS)
Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
Contnet-Length : 6821
Content-Type: text/html
... (데이터)
```

- 위 응답 메시지는 크게 3개의 섹션 (**초기 상태 라인, 6개의 헤더 라인, 개체 몸체**)으로 이루어져 있다.
- 상태 라인은 3개의 필드 (버전 필드, 상태 코드, 해당 상태 메시지)를 갖는다.
- 서버가 사용하는 헤더 라인들은 다음과 같다.
  1. Connection: close: 클라이언트에게 메시지를 보낸 후 TCP 연결을 닫는데 사용한다.
  2. Date : HTTP 응답이 서버에 의해 생성되고 보낸 날짜와 시간을 나타낸다.
  3. Server : 메시지가 아파치 웹 서버에 의해 만들어졌음을 나타낸다. (요청 메시지의 User-agent와 유사)
  4. Last-Modified: 객체가 생성되거나 마지막으로 수정된 시간과 날짜를 나타낸다.
  5. Content-Length : 송신되는 객체의 바이트 수를 나타낸다.
  6. Content-Type : 개체 몸체 내부의 객체가 HTML 텍스트인 것을 나타낸다. 객체 타입은 파일 확장자가 아닌 Content-Type 헤더로 나타낸다.

### 일반적인 상태 코드 및 연관 문장

- 200 OK : 요청이 성공되었고, 정보가 응답으로 보내졌다.
- 300 Moved Permanently : 요청 객체가 영원히 이동되었다. 새로운 URL은 응답 메시지의 Location: 헤더에 나와 있다. 클라이언트 소프트웨어는 자동으로 이 새로운 URL을 추출한다.
- 400 Bad Request : 서버가 요청을 이해할 수 없다는 일반 오류 코드이다.
- 404 Not Found : 요청 문서가 서버에 존재하지 않는다.
- 505 HTTP Version Not Supported : 요청 HTTP 프로토콜 버전을 서버가 지원하지 않는다.

## 사용자와 서버 간의 상호작용 : 쿠키

- HTTP는 상태를 유지하지 않으므로 서버 설계를 간편하게 해 수천 개의 TCP 연결을 다룰 수 있는 고성능 웹 서버를 개발할 수 있게 해주었다. 그러나 서버가 사용자 접속을 제한하거나 사용자에 따라 콘텐츠를 제공하기 원할 때 사용자를 확인해야 할 때도 있으며, 이 목적으로 HTTP는 쿠키(Cookie)를 사용한다.
- 쿠키 기술은 네 가지 요소(**HTTP 응답 메시지 쿠키 헤더 라인, HTTP 요청 메시지 쿠키 헤더 라인, 사용자 브라우저의 사용자 종단 시스템과 관리를 지속 시키는 쿠키 파일, 웹 사이트 백엔드 데이터베이스**)를 갖고 있다.
- 쿠키는 사용자 식별에 사용할 수 있다.
- 사이트에 처음으로 사용자가 방문하면 사용자는 사용자 확인(이름)을 제공하며, 다음 세션 동안에 브라우저는 서버에 쿠키 헤더를 전달해 서버에게 사용자를 확인한다.
  - 쿠키는 비상태 HTTP 위에서 사용자 세션 계층을 생성하는데 이용될 수 있다.

## 웹 캐싱

- 웹 캐시(Web cache; 프록시 서버)는 원출처의 웹 서버(origin Web server)를 대신해 HTTP 요구를 충족시키는 네트워크 개체이다.
- 웹 캐시는 자체 저장 디스크를 갖고 있어 최근 호출된 객체의 사본을 저장 및 보존한다.

Ex) [http://www.someschool.edu/campus.gif라는](http://www.someschool.edu/campus.gif라는) 객체를 요구한다고 가정

1. 브라우저는 웹 캐시와 TCP 연결을 설정하고 웹 캐시에 있는 객체에 대한 HTTP 요청을 보낸다.
2. 웹 캐시는 객체의 사본이 자기에게 저장되어 있는지 확인한다. 저장되어 있다면 웹 캐시는 클라이언트 브라우저로 HTTP 응답 메시지와 함께 객체를 전송한다.
3. 웹 캐시가 객체를 갖고 있지 않다면, 원출처 서버인 www.someschool.edu.로 TCP 연결을 설정하고, 웹 캐시는 캐시와 서버 간의 TCP 연결로 객체에 대한 HTTP 요청을 보낸다. 요청을 받은 후에 기점 서버는 웹 캐시로 HTTP 응답 메시지와 함께 객체를 보낸다.
4. 웹 캐시가 객체를 수신할 때, 객체를 지역 저장장치에 복사하고 클라이언트 브라우저에 HTTP 응답 메시지와 함께 객체의 사본을 보낸다.

- 캐시는 서버이면서 클라이언트이다.
- 웹 캐시는 여러 가지 이유로 즐겨 사용되어 왔다.
  - 클라이언트의 요구에 대한 응답 시간을 줄일 수 있다. (클라이언트와 캐시 간 병목 대역폭이 클아이언트 원출처 서버 사이의 병목 대역폭 보다 훨씬 작을 때 효과적이다)
  - 웹 캐시는 한 기관에서 인터넷으로 접속하는 링크상의 웹 트래픽을 대폭으로 줄일 수 있다.

### 조건부 GET

- 웹 캐싱이 응답 시간을 줄일 수는 있지만, 캐시 내부에 있는 객체의 복사본이 새것이 아닐수 있다는 단점이 있다. 이를 해결하기 위해 HTTP는 모든 객체들이 최신의 것임을 확인하며서 캐싱하는 방식을 갖는데 이것이 조건부 GET이라 한다.
- HTTP 요청 메시지가 GET 방식을 사용하고, If-Modified-Since 헤더라인을 포함하고 있다면 조건부 GET 메시지이다.

---

### 참고 문헌

James F.Kurose & Keith W.Ross. (2017). 표제 : 컴퓨터 네트워킹 하양식 접근 (제7판) (최종원, 강현국, 신용태, 안상현, 유영환 & 황호영 옮김). (퍼스트북)
